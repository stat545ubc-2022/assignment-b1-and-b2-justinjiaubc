R Notebook
================

``` r
suppressPackageStartupMessages(library(palmerpenguins))
suppressPackageStartupMessages(library(lubridate))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(testthat))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(digest))
suppressPackageStartupMessages(library(datateachr))
```

## exercise1&2

``` r
#' Basic data cleaning
#' @details this function deletes omitted observations and keeps observations above a threshold (for example: you can use 0 as the threshold and keep positive observations). 
#'
#' @keywords dataclean
#'
#' @param data the dataset to be cleaned
#' @param x the numeric vector to be cleaned
#' @param n the threshold used to clean data
#'
#' @return returns a cleaned dataset

cleanr<-function(data,x,n){
  stopifnot(is.data.frame(data))
  if(!is.numeric(x)) {
    stop('this function only works for numeric input!\n',
         'You have provided an object of class: ', class(x)[1])
  }
  y<-data%>%
    filter(x>n)%>%
    drop_na()
  return(y)
}
```

## exercise3

In this example, I use building permits dataset and keep the positive
project value.

``` r
cleanr(building_permits,building_permits$project_value,0)
```

    ## # A tibble: 5,555 √ó 14
    ##    permit_n‚Ä¶¬π issue_date proje‚Ä¶¬≤ type_‚Ä¶¬≥ address proje‚Ä¶‚Å¥ build‚Ä¶‚Åµ build‚Ä¶‚Å∂ appli‚Ä¶‚Å∑
    ##    <chr>      <date>       <dbl> <chr>   <chr>   <chr>   <chr>   <chr>   <chr>  
    ##  1 DB-2019-0‚Ä¶ 2020-03-04  997565 New Bu‚Ä¶ 2251 B‚Ä¶ "Low D‚Ä¶ Sian G‚Ä¶ "2177 ‚Ä¶ Mukhti‚Ä¶
    ##  2 DB-2019-0‚Ä¶ 2020-03-04   15000 Demoli‚Ä¶ 2253 B‚Ä¶ "Low D‚Ä¶ Kingsm‚Ä¶ "11895‚Ä¶ Mukhti‚Ä¶
    ##  3 BP-2020-0‚Ä¶ 2020-03-05    8000 Additi‚Ä¶ 870 W ‚Ä¶ "Field‚Ä¶ Lerazo‚Ä¶ "20200‚Ä¶ Deniz ‚Ä¶
    ##  4 BP-2020-0‚Ä¶ 2020-03-05    8000 Additi‚Ä¶ 151 E ‚Ä¶ "Field‚Ä¶ Etro C‚Ä¶ "924 C‚Ä¶ Luba P‚Ä¶
    ##  5 DB-2019-0‚Ä¶ 2020-03-05  678520 New Bu‚Ä¶ 250 E ‚Ä¶ "Low D‚Ä¶ AVS De‚Ä¶ "7 E 4‚Ä¶ Paul S‚Ä¶
    ##  6 BP-2019-0‚Ä¶ 2020-03-06 1200000 New Bu‚Ä¶ 3223 S‚Ä¶ "High ‚Ä¶ Asante‚Ä¶ "4004 ‚Ä¶ Farhan‚Ä¶
    ##  7 BP-2020-0‚Ä¶ 2020-03-06    1500 Additi‚Ä¶ 483 E ‚Ä¶ "Field‚Ä¶ Gurind‚Ä¶ "4558 ‚Ä¶ Gurind‚Ä¶
    ##  8 BP-2020-0‚Ä¶ 2020-03-06   30000 Additi‚Ä¶ 3480 L‚Ä¶ "Field‚Ä¶ Factor‚Ä¶ "1631 ‚Ä¶ Nathal‚Ä¶
    ##  9 BP-2020-0‚Ä¶ 2020-03-06  500000 Additi‚Ä¶ 700 W ‚Ä¶ "Field‚Ä¶ Fusion‚Ä¶ "850 W‚Ä¶ Sandra‚Ä¶
    ## 10 DB-2020-0‚Ä¶ 2020-03-06   60000 Additi‚Ä¶ 3168 E‚Ä¶ "Field‚Ä¶ Brilli‚Ä¶ "1423 ‚Ä¶ Stepha‚Ä¶
    ## # ‚Ä¶ with 5,545 more rows, 5 more variables: applicant_address <chr>,
    ## #   property_use <chr>, specific_use_category <chr>, year <dbl>, bi_id <dbl>,
    ## #   and abbreviated variable names ¬π‚Äãpermit_number, ¬≤‚Äãproject_value,
    ## #   ¬≥‚Äãtype_of_work, ‚Å¥‚Äãproject_description, ‚Åµ‚Äãbuilding_contractor,
    ## #   ‚Å∂‚Äãbuilding_contractor_address, ‚Å∑‚Äãapplicant

I can also keep the project value higher than certain threshold. For
example, I keep high-value project whose value is larger than 100,000.

``` r
cleanr(building_permits,building_permits$project_value,100000)
```

    ## # A tibble: 2,912 √ó 14
    ##    permit_n‚Ä¶¬π issue_date proje‚Ä¶¬≤ type_‚Ä¶¬≥ address proje‚Ä¶‚Å¥ build‚Ä¶‚Åµ build‚Ä¶‚Å∂ appli‚Ä¶‚Å∑
    ##    <chr>      <date>       <dbl> <chr>   <chr>   <chr>   <chr>   <chr>   <chr>  
    ##  1 DB-2019-0‚Ä¶ 2020-03-04  9.98e5 New Bu‚Ä¶ 2251 B‚Ä¶ "Low D‚Ä¶ Sian G‚Ä¶ "2177 ‚Ä¶ Mukhti‚Ä¶
    ##  2 DB-2019-0‚Ä¶ 2020-03-05  6.79e5 New Bu‚Ä¶ 250 E ‚Ä¶ "Low D‚Ä¶ AVS De‚Ä¶ "7 E 4‚Ä¶ Paul S‚Ä¶
    ##  3 BP-2019-0‚Ä¶ 2020-03-06  1.2 e6 New Bu‚Ä¶ 3223 S‚Ä¶ "High ‚Ä¶ Asante‚Ä¶ "4004 ‚Ä¶ Farhan‚Ä¶
    ##  4 BP-2020-0‚Ä¶ 2020-03-06  5   e5 Additi‚Ä¶ 700 W ‚Ä¶ "Field‚Ä¶ Fusion‚Ä¶ "850 W‚Ä¶ Sandra‚Ä¶
    ##  5 DB-2019-0‚Ä¶ 2020-03-09  1.85e5 New Bu‚Ä¶ 49 W 2‚Ä¶ "Low D‚Ä¶ Comfor‚Ä¶ "9271 ‚Ä¶ Hilary‚Ä¶
    ##  6 DB-2019-0‚Ä¶ 2020-03-10  9.93e5 New Bu‚Ä¶ 479 E ‚Ä¶ "Low D‚Ä¶ New Lo‚Ä¶ "280 E‚Ä¶ Gurjit‚Ä¶
    ##  7 DB-2019-0‚Ä¶ 2020-03-10  2.25e5 New Bu‚Ä¶ 483 E ‚Ä¶ "Low D‚Ä¶ New Lo‚Ä¶ "280 E‚Ä¶ Gurjit‚Ä¶
    ##  8 BP-2019-0‚Ä¶ 2020-03-11  1.69e5 Additi‚Ä¶ 3264 O‚Ä¶ "Field‚Ä¶ EPS We‚Ä¶ "15585‚Ä¶ Jaspre‚Ä¶
    ##  9 DB-2019-0‚Ä¶ 2020-03-11  1.93e5 New Bu‚Ä¶ 1282 E‚Ä¶ "Low D‚Ä¶ Orbit ‚Ä¶ "833 E‚Ä¶ Amarde‚Ä¶
    ## 10 DB-2019-0‚Ä¶ 2020-03-11  1.6 e6 Additi‚Ä¶ 2733 W‚Ä¶ "High ‚Ä¶ Waterm‚Ä¶ "955 U‚Ä¶ Mallen‚Ä¶
    ## # ‚Ä¶ with 2,902 more rows, 5 more variables: applicant_address <chr>,
    ## #   property_use <chr>, specific_use_category <chr>, year <dbl>, bi_id <dbl>,
    ## #   and abbreviated variable names ¬π‚Äãpermit_number, ¬≤‚Äãproject_value,
    ## #   ¬≥‚Äãtype_of_work, ‚Å¥‚Äãproject_description, ‚Åµ‚Äãbuilding_contractor,
    ## #   ‚Å∂‚Äãbuilding_contractor_address, ‚Å∑‚Äãapplicant

I use a character type_of_work and get an error.

``` r
cleanr(building_permits,building_permits$type_of_work,0)
```

    ## Error in cleanr(building_permits, building_permits$type_of_work, 0): this function only works for numeric input!
    ## You have provided an object of class: character

## exercise4

In building_permits dataset, project_value is a numeric vector and has
NA‚Äôs, type_or_work is a character vector. In cancer_sample dataset,
radius_mean has non NA‚Äôs

``` r
data1<-building_permits%>%
    filter(project_value>0)%>%
    drop_na()
data2<-building_permits%>%
    filter(type_of_work>0)%>%
    drop_na() 
data3<-cancer_sample%>%
    filter(radius_mean>10)%>%
    drop_na() 
```

``` r
test_that("Testing function1", {
  expect_equal(cleanr(building_permits,building_permits$project_value,0),data1)})
```

    ## Test passed ü•≥

``` r
test_that("Testing function2", {
   expect_error(cleanr(building_permits,building_permits$type_of_work,0),"this function only works for numeric input!
You have provided an object of class: character")})
```

    ## Test passed üòÄ

``` r
test_that("Testing function3", {
   expect_equal(cleanr(cancer_sample,cancer_sample$radius_mean,10), data3)})
```

    ## Test passed üò∏
